module Monads.UnderstandMonads where
  
import Prelude

printSomethingTwice :: String -> IO ()
printSomethingTwice str = putStrLn str >> putStrLn str >> putStrLn str

foo :: (Show a, Num a) => a -> a
foo x = x + 5

displayResult :: Maybe Int -> String
displayResult mx = maybe "There was no result" (("The result was " ++) . show) mx

themselvesTimes :: [Int] -> [Int]
themselvesTimes xs = xs >>= replicateCount

replicateCount :: Int -> [Int]
replicateCount x = replicate x x

-- The book's solution
themselvesTimes' :: [Int] -> [Int]
themselvesTimes' xs = xs >>= \n -> replicate n n


{-
Last Exercises:

What (<*>) does is: for each function in a list,
map that function across each element in a list, then
concatenate the generated list to the list generated by the previous function.

xs >>= f = concat (map f xs)

I dont' know how to implement the following
without map, concate, or concatMap explicitly
(>>=') :: Monad m => m a -> (a -> m b) -> m b

Here's how the book did it:
-}
fs <*> xs = [ f x | f <- fs, x <- xs ]
